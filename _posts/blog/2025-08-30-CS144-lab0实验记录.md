在lab0中有以下四个任务。

**任务一：获取一个web页面**，页面网址为 http://cs144.keithw.org/lab0/sunetid。在返回的HTTP头中存在一个 `X-Your-Code-Is`字段， 记录下字段值 `SUNetID`。

解决方法：将`handout`中步骤b ` GET /hello HTTP/1.1`替换成`GET /lab0/sunetid HTTP/1.1`。`SUNetID=725042`

```scss
telnet cs144.keithw.org http
GET /lab0/sunetid HTTP/1.1  //指明资源路径
Host: cs144.keithw.org
Connection: close
```

**任务二：给自己或他人发送`Email`**

```scss
telnet 148.163.153.234 smtp  //建立tcp连接
HELO mycomputer.stanford.edu  //标识客户端

MAIL FROM: 725042@stanford.edu  //发件人
RCPT TO:  cs144grader@gmail.com //收件人
DATA //准备发送数据


From: 725042@stanford.edu    //数据
To: cs144grader@gmail.com
Subject: Hello from CS144 Lab 0!
Hello!


QUIT //退出
```

 **任务三：模拟HTTP get请求**。需使用己提供的socket接口，而不是c++原生的socket接口。

```c++
void get_URL(const string &host, const string &path) {
    
    // Your code here.
    TCPSocket client;
    Address server_addr(host, "http");
    client.connect(server_addr);

    //构建http请求
    std::string request = "GET " + path + " HTTP/1.1\r\n";
    request += "Host: " + host + "\r\n";
    request += "Connection: close\r\n";
    request += "\r\n";  // 请求头结束标志

    client.write(request);
    
    std::string buffer;
    while(!client.eof()){
        client.read(buffer);
        cout << buffer;
    }
  
}
```

**任务四 实现一个byte_stream**  

实验要求实现的`byte_stream`是一个在内存中有序的字节流，且该字节流是无限长的。由可知，应该使用环形数组实现。类定义如下：

```c++
class ByteStream {
  private:
    // Your code here -- add private members as necessary.
    std::vector<char> buffer_;  // 存储队列元素的缓冲区
    size_t head_;               // 队头指针，指向第一个有效元素
    size_t tail_;               // 队尾指针，指向最后一个有效元素的下一个位置
    size_t count_;              // 当前元素数量
    const size_t capacity_;     // 队列最大容量
    bool input_ended_;
    size_t bytes_written_;
    size_t bytes_read_;
    bool _error{};  //!< Flag indicating that the stream suffered an error.

public:
    ...
};

```

在读和写byte_stream时，由于底层数据结构是环形数据，需处理分段的情况

```c++
//! \param[in] len bytes will be copied from the output side of the buffer
string ByteStream::peek_output(const size_t len) const {
    if (len == 0 || count_ == 0) return "";
        
    // 确定要读取的字符数
    size_t to_read = std::min(len, count_);
    std::string result;
    // result.reserve(to_read);
    
    // 分两段读取（如果需要）
    size_t first_segment = std::min(to_read, capacity_ - head_);
    result.append(buffer_.begin() + head_, buffer_.begin() + head_ + first_segment);
    
    if (to_read > first_segment) {
        size_t second_segment = to_read - first_segment;
        result.append(buffer_.begin(), buffer_.begin() + second_segment);
    }

    return result;
}
```

```c++
std::string ByteStream::read(const size_t len) {
        
        if (len == 0 || count_ == 0) return "";
        
        // 确定要读取的字符数
        size_t to_read = std::min(len, count_);
        std::string result;
        // result.reserve(to_read);
        
        // 分两段读取（如果需要）
        size_t first_segment = std::min(to_read, capacity_ - head_);
        result.append(buffer_.begin() + head_, buffer_.begin() + head_ + first_segment);
        
        if (to_read > first_segment) {
            size_t second_segment = to_read - first_segment;
            result.append(buffer_.begin(), buffer_.begin() + second_segment);
        }
       
        // 更新队头指针和元素数量
        head_ = (head_ + to_read) % capacity_;
        count_ -= to_read;
        bytes_read_ += to_read;
        
        return result;
}
```



