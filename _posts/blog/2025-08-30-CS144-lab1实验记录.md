**lab1需要实现一个`StreamReassembler`**。`StreamReassembler`接收碎片,并根据它在`stream`的偏移插入`first_unread`和`first unacceptable`之间。若与己有的红色碎片有重叠部，进行合并。若产生了与绿色块之间无空隙的碎片，立即与绿色块合并。

<center>
    <img src="/images/posts/blog/CS144/receiver_stream.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>

实现思路：使用有序容器`map`存储红色碎片，key为碎片在stream的偏移`index`，`value`为碎片本身。对于接收到的碎片，对于接收到的碎片，需遍历map，找到它能够插入的位置。很明显，若它的最后一字节的偏移小于某个红色碎片的第一字节的偏移`new_end < cur_index`，应插入到此经色碎片之前。在遍历过程中，若发现与当前碎片有overlap的部分，即`!(new_end < cur_start) && !(new_start > cur_end)`,与当前碎片合并，继续遍历，直到找到碎片的插入位置。

```c++
    auto it = _parts.begin();
    while(it != _parts.end()){
        size_t cur_start = it->first;
        string cur_part = it->second;
        size_t cur_end = cur_start + cur_part.length();
        if(new_end < cur_start) break;
        if(! (new_start > cur_end)){
            //overlap
            size_t min_start = min(new_start, cur_start);
            size_t max_end = max(new_end, cur_end);
            string merge_part(max_end - min_start, '\0'); 
            merge_part.replace(cur_start - min_start, cur_part.length(), cur_part);
            merge_part.replace(new_start - min_start, new_data.length(), new_data);
            new_data = merge_part;
            new_start = min_start;
            new_end = max_end;
            it = _parts.erase(it);
            _unassembled_bytes -= cur_part.length();
        }else{
            ++it;
        }
    }
    _parts[new_start] = new_data;
    _unassembled_bytes += new_data.length();
```

在插入碎片到`map`后，若map中第一个红片碎片与绿色块没有间隙，移出map与绿色块合并，即写入`byte_stream`。

```c++
auto first_ele = _parts.begin();
if(first_ele->first == _first_unassembled){
    _output.write(first_ele->second);
    _unassembled_bytes -= first_ele->second.length();
    _parts.erase(first_ele);
    if(_eof && first_unassembled() == _eof_index) _output.end_input(); //判断是否己将eof前一个字节也写入                                                                                  byte_stream,即己按序接收所有的字节。
}
```

由于内存有限，即`capacity`大小不变，所以碎片中偏移在`first_unread`和`first_unacceptable之间字节才能放到map中。

``` c++
string new_data = data;
size_t new_start = index, new_end = index + data.length();
if(eof){
    _eof =eof;
    _eof_index = new_end; //记录eof位置
} 
if(new_start == new_end){
    if(_eof && new_end == first_unassembled()) _output.end_input(); //处理带有eof的空字符串
    return;
}
size_t  _first_unassembled= first_unassembled();
size_t _first_unacceptable  = first_unacceptable();
if(new_end <= _first_unassembled || new_start >= _first_unacceptable) {
    return;
}
if(new_start < _first_unassembled){
    new_data = new_data.substr(_first_unassembled - new_start);
    new_start = _first_unassembled;
}
if(new_end > _first_unacceptable){
    new_data = new_data.substr(0, _first_unacceptable - new_start);
    new_end = _first_unacceptable;
}
```

