**TCP Sender**

Receiver用byte_stream和reassembler构造接收端的字节流，同理Sender用filghting_segs和byte_stream构造发送端字节流，fighting_segs保存己经发送但未确认的数据段。

```c++
struct flighting_seg
{
  uint64_t absolute_seqno;
  TCPSegment seg;
};

class TCPSender {
  private:
   
    //! outgoing stream of bytes that have not yet been sent
    ByteStream _stream;
    //! the (absolute) sequence number for the next byte to be sent
    uint64_t _next_seqno{0};
    std::vector<flighting_seg> _flighting_segs{};
    size_t  _bytes_in_flight{0};
    uint64_t _window_size{1};
    
    ...
}
```

**fill_windows**

`fill_window`函数的目标是根据发送窗口尽可能将己有的字节流数据（包含syn、data和fin）发送出去。发送窗口大小等于对端的接收窗口减去己发送的数据大小，即`_window_size - _bytes_in_flight`。若`_next_seqno==0`，发送SYN报文。 观察sender状态转换图可知，只有_next_seqno >  _bytes_in_flight时，sender才能尝试发送data和fin信号。

<center>
    <img src="/images/posts/blog/CS144/sender_states.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>

发送数据段时，需同步将数据段保存到`_flighting_segments`中，等收到对端的确认，才可从`_flight_segment`中移除。

```c++
void TCPSender::fill_window() {
    
    if(_next_seqno == 0){
        TCPSegment segment;
        TCPHeader & header = segment.header();
        header.syn = true;
        header.seqno = _isn;
        _segments_out.push(segment);
        _flighting_segs.push_back({_next_seqno, segment});
        _retransmission_timer.start(_retransmission_timeout);
        _next_seqno  = 1;
        _bytes_in_flight = 1;
        
    }else{
        if(_next_seqno > _bytes_in_flight){
            size_t total_len = 0;
            size_t len;
            uint64_t wnd = _window_size != 0 ? _window_size : 1;
            do{
                TCPSegment segment;
                TCPHeader & header = segment.header();
                Buffer & payload  = segment.payload();
                size_t bytes_read = std::min(wnd - _bytes_in_flight, TCPConfig::MAX_PAYLOAD_SIZE);
                string data = stream_in().read(bytes_read);
                payload = std::move(data);
                header.seqno = wrap(_next_seqno, _isn);
                //窗口大小允许、应用程序己经停止写byte_stream且byte_stream中数据己经全部读取时，发送fin
                if(stream_in().eof() && _next_seqno  < stream_in().bytes_written() + 2){
                    if(payload.size() + 1 <=  wnd - _bytes_in_flight){
                        header.fin = true;
                    }
                }
                len  = segment.length_in_sequence_space();
                total_len += len;
                if(len != 0){
                    _segments_out.push(segment);
                    _flighting_segs.push_back({_next_seqno, segment});
                }
                _next_seqno += len;
                _bytes_in_flight += len; 
                
            }while(len != 0);
            
            if(total_len != 0 && !_retransmission_timer.started()){
                 _retransmission_timer.start(_retransmission_timeout);
            }
           
        }
    }
    
}
```

**ack_received**

ack_received根据接收到确认序列号和窗口通知更新`_window_size`和`_flighting_segment`。

什么时候应该更新_window_size呢？

- 收到的ack序号确认了数据
- 未确认数据，但接收到的窗口比当前_window_size大

收到确认号后，_fligthting_segment哪些segment应该被移除 ?  segment的字节流数据首字节的的abosulte seqno +数据长度  <=  确认号对应abosulte seqno

```c++
void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {
    uint64_t absolute_ackno = unwrap(ackno, _isn, _next_seqno - _bytes_in_flight);
    if(absolute_ackno < _next_seqno - _bytes_in_flight || absolute_ackno > _next_seqno) return;
    size_t size_ack = 0;
    auto it = _flighting_segs.begin();
    while(it != _flighting_segs.end()){
       uint64_t seqno = it->absolute_seqno;
       uint64_t size = it->seg.length_in_sequence_space();
       if( seqno + size > absolute_ackno) break;
       size_ack += size;
       it = _flighting_segs.erase(it);

    }
    //_window_size = wnd;
    _bytes_in_flight -= size_ack;
    uint16_t wnd = window_size;
    if(size_ack != 0 || wnd > _window_size){
       _window_size = wnd;
    }

    
    if(size_ack != 0){
        _retransmission_timeout = _initial_retransmission_timeout;
        _consecutive_retransmissions = 0;
        if(!_flighting_segs.empty()){
            _retransmission_timer.start(_retransmission_timeout);
        }else{
            _retransmission_timer.stop();
        }
    }
    
    
}
```



**超时重传**

TCP segment的传输依赖IP尽力而为的交付服务，发送的segment及ack包可能在传输过程丢失。 在等待一段时间仍未收确认，需将segment重传。

首先模拟一个超时重传计时器。

```c++
class Timer {
   private:
      size_t _remaine_time;
      bool _started;
   public:    
     void start(size_t timeout_ms);
     void stop();
     void decrease_time( const size_t ms_since_last_tick);
     bool started();
     bool expired();
     
};
class TCPSender {
  private:
    //! retransmission timer for the connection
    unsigned int _initial_retransmission_timeout;
    
    Timer _retransmission_timer{};

    unsigned int _retransmission_timeout{0};
    ...
}
```

 tick函数被周期性调用减少计时器的毫秒数。当计时器超时，重传_flighting_segs的第一个segment，并重新启动计时器

```c++
void TCPSender::tick(const size_t ms_since_last_tick) { 
    if(_retransmission_timer.started()){
        _retransmission_timer.decrease_time(ms_since_last_tick);
        if(_retransmission_timer.expired()){
            auto front_seg = _flighting_segs.front().seg;
            _segments_out.push(front_seg);
            if(_window_size != 0){
                _consecutive_retransmissions += 1;
               _retransmission_timeout *= 2 ; //指数退避
            }
            //重启计时器
            _retransmission_timer.start(_retransmission_timeout);
        }
    }
 }
```

 有三种情况需要启动计时器。1）在计时器超时后，重新启动；2）有segment发送但超时计时器未启动

```c++
void TCPSender::fill_window() { 
     ...        
     if(total_len != 0 && !_retransmission_timer.started()){
          _retransmission_timer.start(_retransmission_timeout);
     }  
}
```

3)根据确认号更新`_flighting_segments`后，`_fligting_segment`中仍有segment时，重启。

```
    if(size_ack != 0){
        _retransmission_timeout = _initial_retransmission_timeout;
        _consecutive_retransmissions = 0;
        if(!_flighting_segs.empty()){
            _retransmission_timer.start(_retransmission_timeout);
        }else{
            _retransmission_timer.stop();
        }
    }
```

