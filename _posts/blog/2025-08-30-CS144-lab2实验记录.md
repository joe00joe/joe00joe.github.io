**实验一：32位`seqno`与64位`absolute seqno`之间转换**

`absolute seqno`是字节在流中的序号，64位长，从0开始。syn和fin信号也占有一个序号。而`tcp`头中`seqno`字段只有32位长，且从随机值`isn`开始。

<center>
    <img src="/images/posts/blog/CS144/seqno.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>

`warp`函数将`absolute seqno`转换成`seqno`，即`isn`加上`absolute seqno`的低32位。由于只取了低32位，那在接收到`seqno`时，`seqno`可以映射到多个`absolute seqno`，需要`checkpoint`来确定是哪一个。哪一个`absolute seqno`离`checkpoint`最近的哪一个。checkpoint为第一个未被组装字节的`absolute seqno`。假设`seqno`3位长，即序列号空间大小为8。那么`absolute seqno` 0、8、16都可对应`seqno` 0。若此时checkpoint为6，那么选择距离最近的8。

```c++
WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) {
    
    return isn + static_cast<uint32_t>(n);
}

uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) {
    uint64_t offset = static_cast<uint64_t>( n - isn);
    uint64_t base = (checkpoint >> 32) << 32;
    std::vector<uint64_t> guesses {base - ((1ul << 32)) + offset,
                                   base + offset,
                                   base + ((1ul << 32)) + offset};
    
    return filteMinDistance(gusses, checkpoint);
}
```



实验二：TCP receiver

`segment_received`接收字节流数据（data、syn和fin)，当时收到`syn`时，需记录下`isn`。`data`和`fin`交给`push_substring`处理。在`push_substring`中，当fin为true且fin信号之前的字节己被组装，会调用stream_out().input_end()。

```c++
void TCPReceiver::segment_received(const TCPSegment &seg) {
    TCPHeader head = seg.header();
    if(!_syned && head.syn){
        _syned = true;
        _isn = head.seqno;
    }
    std::string data = seg.payload().copy();
    uint64_t checkpoint = _reassembler.first_unassembled() + 1;
    if(_syned){
        if(head.syn &&  head.seqno != _isn) return; //repeat syn!
        if(head.syn ){
            _reassembler.push_substring(data, 0, head.fin);
        }else{
            _reassembler.push_substring(data,unwrap(head.seqno, _isn, checkpoint) - 1, head.fin ); 
        }
        
    }
   
    
}
```

`ackno`函数warp字节流中第一个未组装字节的 `absolute seqno`。

```c++
optional<WrappingInt32> TCPReceiver::ackno() const { 
    if(_syned){
        int fin = _reassembler.stream_out().input_ended() ? 1 : 0;
        return wrap(_reassembler.first_unassembled() + 1 + fin, _isn);
    }
    return std::nullopt;
}

```

`window_size`返回缓冲区还能接收的字节数量。

```c++
size_t TCPReceiver::window_size() const {
     return _reassembler.first_unacceptable() - _reassembler.first_unassembled(); }
```

 以上的函数隐含了receiver的状态转换。比如，在未收到syn信号时，`_syn`为false，那么`not ackno_has_value()`,receiver处于LISTEN状态。收到syn信号后，_syn为true，`ackno_has_value()  and not stream_out().inpute_ended()`成立，进入SYN_RECV。同理，SYN_RECV转换到FIN_RECV也是如此，读者自行推敲。

<center>
    <img src="/images/posts/blog/CS144/receiver_states.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>

