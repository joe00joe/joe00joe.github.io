lab4要求将前两个实验实现的sender和receiver组合成完整的tcp实现。

```c++
class TCPConnection {
  private:
    TCPConfig _cfg;
    TCPReceiver _receiver{_cfg.recv_capacity};
    TCPSender _sender{_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn};
   
    bool _linger_after_streams_finish{true};
    bool _active{true};
    '''
    }
```

**1. TCP状态机**

在动手之前，首先要理解TCP的状态机。

<center>
    <img src="/images/posts/blog/CS144/fsm.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>

TCP状态机的的每一个状态都由sender和receiver的状态决定的。比如，当TCP处于listen状态时，未发送(`_abosulte_seqno = 0`)也未接收任何数据(`not ackno().has_value()`)，receiver的状态为LISTEN，sender为CLOSED。当收到SYN报文段后，需调用receiver的segment_recevier方法接收。接收后，`ackno().has_value()`为空，receiver进入SYN_RECV状态。作为对SYN的回应，调用sender的fill_window函数产生一个SYN报文并将报文的ack标志置位，发送出去。此时sender的`byte_in_flight() > 0 && _abosulte_seqno = byte_in_flight()`,即进入SYN_SENT状态。至此，TCP进入了SYN_RECV状态。通过以上分析可知，我们不需要模拟一个真实的状态，而应该通过改变sender和receiver的状态间接地完成TCP状态机的转换。

```c++
switch (state) {
        case TCPState::State::LISTEN:
            _receiver = TCPReceiverStateSummary::LISTEN;
            _sender = TCPSenderStateSummary::CLOSED;
            break;
        case TCPState::State::SYN_RCVD:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::SYN_SENT;
            break;
        case TCPState::State::SYN_SENT:
            _receiver = TCPReceiverStateSummary::LISTEN;
            _sender = TCPSenderStateSummary::SYN_SENT;
            break;
        case TCPState::State::ESTABLISHED:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::SYN_ACKED;
            break;
        case TCPState::State::CLOSE_WAIT:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::SYN_ACKED;
            _linger_after_streams_finish = false;
            break;
        case TCPState::State::LAST_ACK:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            _linger_after_streams_finish = false;
            break;
        case TCPState::State::CLOSING:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            break;
        case TCPState::State::FIN_WAIT_1:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            break;
        case TCPState::State::FIN_WAIT_2:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            break;
        case TCPState::State::TIME_WAIT:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            break;
        case TCPState::State::RESET:
            _receiver = TCPReceiverStateSummary::ERROR;
            _sender = TCPSenderStateSummary::ERROR;
            _linger_after_streams_finish = false;
            _active = false;
            break;
        case TCPState::State::CLOSED:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            _linger_after_streams_finish = false;
            _active = false;
            break;
```

可将TCP的状态转换分成两类：1）主动发出信号，如CLOSED-->SYN_SENT和ESTABLISHED-->FIN_WAIT1；2）被动接收信号并做出相应动作，如LISTEN-->SYN_RECV， ESTABLISHED-->CLOSE_WAIT。

**1.1 第一类转换**

在Client尝试建立连接时, 发送syn报文。调用fill_windows，构造一个包含syn标志和初始序列号的SYN报文，添加wnd后发送。这使得sender满足条件`_bytes_in_flight  > 0 && _next_seqno == _byte_in_flight`， 进入SYN_SENT状态，而Client状态恰好从CLOSE转换到SYN_SENT。

```c++
void TCPConnection::connect() {
    _sender.fill_window(); //send syn segment
    _active = true;
    attach_with_win_ack();
}

void TCPConnection::attach_with_win_ack(){
    while(!_sender.segments_out().empty()){
       TCPSegment& seg = _sender.segments_out().front();
       TCPHeader& header  = seg.header();
       size_t wnd = _receiver.window_size();
       header.win = wnd;
       if(TCPState::state_summary(_receiver) ==TCPReceiverStateSummary::SYN_RECV
          || TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV){
         header.ack = true;
         header.ackno = _receiver.ackno().value();
       }
       //std::cerr << "sent segment's header: " << seg.header().to_string()<< endl; 
       _segments_out.push(seg);
       _sender.segments_out().pop();
    }
 }
```

**1.2 第二类转换**

第二类转换由segment_receiver函数处理。比如，Client处于SYN_SENT状态时，收到SYN/ACK报文后，完成以下步骤：

- 构造一个空报文。
- 调用receiver的segment_received，使其进入SYN_RECV状态。
- 调用sender的ack_received，移除_flighting_segments中SYN报文，使其转换为SYN_ACKED状态。
- 空报文添加ack标记以及确认号。



```c++
void TCPConnection::segment_received(const TCPSegment &seg) { 

   ...
   if(header.syn ){

     if(state() == TCPState{TCPState::State::SYN_SENT}){
        _sender.send_empty_segment();
        // SYN_SENT --> SYN_RECV
        if(!header.ack){
           //TCPSegment& syn_ack_seg = _sender.segments_out().front();
           //syn_ack_seg.header().syn = true;   
        }
     }
     ...
   }else if(seg.length_in_sequence_space() != 0){ //recv data or fin
    ...
   }
   _receiver.segment_received(seg);
   if(header.ack){
    _sender.ack_received(header.ackno, header.win);
    ...
   }   
   attach_with_win_ack();      
   ...
    
}
```

**1.3 TIME_WAIT**

对于被动关闭的一方（接收字节流比发送字节流先关闭），在它处于LAST_ACK状态时，收到ACK报文后，立即进入CLOSE状态。

```c++
void TCPConnection::segment_received(const TCPSegment &seg) { 

   ...

   _receiver.segment_received(seg);
   if(header.ack){
   
    _sender.ack_received(header.ackno, header.win);
    if(TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV
        && TCPState::state_summary(_sender) ==TCPSenderStateSummary::FIN_ACKED
        && _linger_after_streams_finish == false){
          _active = false; //LAST_ACK --> ClOSED
    }
    ...
   }   
   ...   

   // Set the flag on the end that doesn't need to wrap around
   if(_receiver.stream_out().input_ended() && !_sender.stream_in().input_ended()){
    _linger_after_streams_finish  = false;
   }

   ...
    
}
```

主动关闭的一方在发送对另一方fin的ACK包后并不能直接关闭，因为这个ACK可能会丢失。需要等待`10*_cfg.rt_timeout`后关闭

```c++
//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method
void TCPConnection::tick(const size_t ms_since_last_tick) { 
    _time += ms_since_last_tick;
    ...
    if(state() == TCPState{TCPState::State::TIME_WAIT}){
        if(time_since_last_segment_received() >= 10 * _cfg.rt_timeout){
            _linger_after_streams_finish = false;
            _active = false;
        }
    }
    
```



其它的状态转换不再赘述。

**2. 发送字节流数据的时机**

字节流数据包含了syn、data和fin。

Client的syn信号是通过调用connect函数立即发送，而server的syn信号是在在收到SYN包后由SYN/ACK携带发送。

可以调用write函数尝试发送data。

```c++
size_t TCPConnection::write(const string &data) {
   size_t size  = _sender.stream_in().write(data);
   _sender.fill_window(); 
   attach_with_win_ack();
   return size;
    
}
```

因为发送窗口有限，有可能只发送了少量的数据。如果出现这种请况，剩余的数据何时发送? 己发送的数据段必然会被确认，也就是会收到相应的ACK报文，在收到ACK报文后，可尝试调用fill_window发送数据。

```
void TCPConnection::segment_received(const TCPSegment &seg) { 

   ...
   if(header.syn ){
     ...
   }else if(seg.length_in_sequence_space() != 0){ //recv data or fin
     _sender.fill_window();
     if(_sender.segments_out().empty()){
        _sender.send_empty_segment();
     }
   }

   _receiver.segment_received(seg);
   if(header.ack){
   
    _sender.ack_received(header.ackno, header.win);
    ...   
    if(TCPState::state_summary(_sender) == TCPSenderStateSummary::SYN_ACKED){
         _sender.fill_window();
    }
   }   
   attach_with_win_ack();      

   ...
    
}
```

发送fin时，也可能因为发送窗口太小，fin信号无法立即发送。解决方法和之前一样，在收到fin之前数据的ACK包后，尝试调用fill_window发送。

```c++
void TCPConnection::end_input_stream() {
   _sender.stream_in().end_input();
   _sender.fill_window();
    attach_with_win_ack();
}
```

**3. tick**

在第2节提到发送的数据总是能得到确认，这由超时重传机制保证。实际上就是周期性调用sender的tick函数。

```c++
void TCPConnection::tick(const size_t ms_since_last_tick) { 
    _time += ms_since_last_tick;
    _sender.tick(ms_since_last_tick);
    attach_with_win_ack();
    ...
    }
```

**4. rst**

收到rst包后，重置状态到RESET

```c++
void TCPConnection::segment_received(const TCPSegment &seg) { 

   //std::cerr << "recv segment's header: " << seg.header().to_string()<< endl; 
   _time_last_segment_received = _time;
   const TCPHeader& header  = seg.header();
   if(header.rst) {
     _active = false;
     _linger_after_streams_finish = false;
     _receiver.stream_out().set_error();
     _sender.stream_in().set_error();
     return;
   }
   ...
 }
```

两种情况会发送rst包：1）同一个报文，重传次数超过`TCPConfig::MAX_RETX_ATTEMPTS` ; 2)调用了析构函数时，连接处于active状态。

```c++
void TCPConnection::tick(const size_t ms_since_last_tick) { 
    _time += ms_since_last_tick;
    _sender.tick(ms_since_last_tick);
    attach_with_win_ack();
    if(_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS){
        _active = false;
        _linger_after_streams_finish = false;
        _sender.stream_in().set_error();
        _receiver.stream_out().set_error();
        //clear
        while (!_segments_out.empty()) {
            _segments_out.pop();
        }
        send_rst_segment();
    }
    ...
}

TCPConnection::~TCPConnection() {
    try {
        if (active()) {
            cerr << "Warning: Unclean shutdown of TCPConnection\n";
            
            // Your code here: need to send a RST segment to the peer
            send_rst_segment();
        }
    } catch (const exception &e) {
        std::cerr << "Exception destructing TCP FSM: " << e.what() << std::endl;
    }
}

    
```

