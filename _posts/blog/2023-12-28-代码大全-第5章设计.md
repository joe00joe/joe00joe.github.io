### 5.1 设计中的挑战

+ **设计是一个险恶问题** 你必须首先把这个问题“解决”遍以便能够明确地定义它，然后再次解决该问题，从而形成一个可行的方案。比如`Tacoma Narrows`大桥的设计问题。大桥在设计之初未考虑空气动力学问题，在建成后因大风倒塌。之后建设的大桥都考虑了这一问题。
+ **设计是一个了无章法的问题** 设计过程不可避免的会犯错，需在不断调整完善设计。
+ **设计受到限制** 系统能利用的资源是有限且需要在不同的指标之间进行折衷
+ **设计是不确定** 同一问题可能有不同的解决方案，同一系统可能有不同的设计方案。
+ **设计是自然而然形成的** 设计在不断设计评估、讨论和修改代码中形成的。

###  

### 5.2 关键的设计概念 

**管理复杂度** 两类不同的问题导致软件开发变得困难---本质问题和偶然问题。

偶然属性指一件事物碰巧具有的属性，有没有这些属性都不影响这件事物本身。一辆汽车可能是两门也可能是四门，不影响它是辆汽车。系统实现要可以以不同的方式完成，如软件实现或硬件实现，只是这些方式困难程度不同。这类针对偶然属性（非本质属性）的实现问题是软件开发中的偶然性问题。这些偶然性问题大部分己经获取解决，比如与笨拙的语法相关的那些偶然性难题大多已在从汇编语言到第三代编程吾言的演进过程中被解决了，而且这类问题的重要性也渐渐下降了。

在软件开发剩下的那些本质性困难上的进展将会变得相对缓慢。究其原因，是因为从本质上说软件开发就是不断地去发掘错综复杂、相互连接的整套世界概念的所有细节。其本质性的困难来自很多方面:必须去面对复杂、无序的现实世界;精确而完整地识别出各种依赖关系与例外情况:设计出完全正确而不是大致正确的解决方案;诸如此类。



**如何应对复杂度**

程序员不应该试着在同一时间把整个程序都塞进自己的大脑里，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注一个特定的部分，尽量减少在任一时间所要考虑的程序量。

在软件架构的层面上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。子系统章的相互依赖越少，就越容易在同一时间专注问题的一小部分。

用下以两种方法来管理复杂度：

+ 把任何人在同一时间需要处理的本质复杂度的量减少到最少
+ 不要让偶然性的复杂度无谓地快速增长

**理想设计特征**

+ **最小的复杂度**
+ **易于维护** 设计出自明的系统
+ **松散耦合** 程序的各个组成部分之间关联最小。利用类接口由合理抽象、封装等原则，设计出相互关联尽可能少的类。
+ **可扩展性** 能增加系统的功能而无须破坏其底层结构。
+ **可重用性** 系统的功能可在其它的系统中重用。
+ **高扇出和低扇入** 类大量地被其它类使用，少量地使用其它类
+ **可移植性** 轻松地移植到其它环境（操作系统、硬件平台等）
+ **层次性** 参见TCP/IP协议栈。
+ **标准技术** 使用业界常用的语言、开发框架和开发工具等

**设计的层次**

+ **软件系统** 从子系统开发设计
+ **分解为子系统或包** 在这一层次上设计的主要成果是识别出所有的主要子系统。这些子系统可能会很大，比如说数据库、用户界面、业务规则、命令解释器、报表引擎等。这一层的主要设计活动就是确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其他子系统。子系统的之间的依赖要尽可能少
+ **分解成类** 在这一层次上的设计包括识别出系统中所有的类。例如，数据库接口子系统可能会被进一步划分成数据访问类、实体类等。定义子系统中的类时，同时也要定义好类的接口
+ **分解成子程序**  确定类的行为，用子程序实现。

### 5.3 设计构造块： 启发式方法

**对象设计**

+ 辨识对象及其属性（method和data）
+ 确定可以对各个对象进行的操作
+ 确定对象的哪些部分对其它对象可能（public或private）
+ 定义每个对象的公开接口（interface）

**抽象与封装**

抽象是说:“可以让你从高层的视角来看待一个对象。”而封装则说:“除此之外，你不能看到对象的任何其他细节。"

基类也是一种抽象，它使你能集中精力关注一组派生类所具有的共同特性并在基类的层次上忽略各个具体派生类的细节。一个好的接口也是一种抽象，它能让你关注于接口本身而不是类的内部工作方式。一个设计良好的子程序接口也在较低的层次上提供了同样的好处，而设计良好的包(package) 和子系统的接口则在更高的层次上提供了同样的好处。

**继承**

定义这种对象之间的相同点和不同点就叫“继承”，比如全职员工类型和特殊的兼职员工类型都从基本员工类型继承了某些特征。通过继承可以简化代码编写和形成基类抽象。

**信息隐藏**

信息隐藏是结构化程序设计与面向对象设计的基础之一。结构化设计里面的“黑盒子”概念就是来源于信息隐藏。在面向对象设计中，它又引出了封装和模块化的概念，并与抽象的概念紧密相关。

隐藏起来的秘密可能是某个易变的区域，或者某种文件格式或某种数据类型的实现方式，或某个需要隔离的区域，在这个区域中发生的错误不会给程序其余部分带来太大损失。比如说，系统中对象的ID，id可以简单地用一个int变量实现。每创建一个对象，id+1分配给对象。万一需要保留某些范围的id值，那么对于所有创建对象的代码都要改变id的产生方式。如果没有修改，那么就会出错。我们可以用ID类代替int变量,让ID类中`newId`方法隐藏id值的分配。

**找出容易变化的区域**

+ 找出看起来容易变化的区域  这区域包括业务规则、对硬件的依赖、输入输出、困难的设计区域待等
+ 将容易变化的区域隔离 

**松散耦合**

模块之间的好的耦合关系会松散到恰好能使一个模块能够很容易地被其他模块使用。火车模型之间通过环钩彼此相连，把两辆列车连起来非常容易----只用把它们钩起来就可以了。设想如果你必须要把它们用螺丝拧在一起，或者要连很多的线缆，或者只能连接某些特定种类的车辆，那么连接工作会是多么复杂。

松散耦合（模块好用）的关键之处在于，一个有效的模块提供出了一层的抽象一旦你写好了它，你就可以想当然地去用它。这样就降低了整体系统的复杂度，使得你可以在同一时间只关注一件事。如果对一个模块的使用要求你同时关注好几件事----其内部工作的细节、对全局数据的修改、不确定的功能点等一一那么就失去了抽象的能力，模块所具有的管理复杂度的能力也削弱或完全丧失了。

耦合标准：

+ **模块的连接数** 只有一个参数的子程序与调用它的子程序之间的耦合关系比有六个参数的子程序与它的调用方之间的合关系更为松散。包含 4 个定义明确的公用方法的类与它的调用方的合关系，比包含 37 个公用方法的类与它的调用方的耦合关系更为松散。
+ **可见性** 向另一个子程序传递参数相比于偷偷修改全局变量好
+ **灵活性** 灵活性指的是模块之间的连接是否容易改动。

**查看常用的设计模式** 

`GoF`的23种设计模式

**启发式方法的原则**

波利亚的《如何解题》

### 5.4 设计实践

**分而治之**

把程序分解为不同的关注区域，然后分别处理每一个区域。如果你在某个区域里碰上了死胡同，那么就迭代!

**自上向下设计和自下向上设计**

自上而下的设计从某个很高的抽象层次开始你定义出基类或其他不那么特殊的设计元素，逐渐增加细节的层次，找出派生类、合作类以及其他更细节的设计元素。
自下而上的设计始于细节，向一般性延伸。这种设计通常是从寻找具体对象开始，最后从细节之中生成对象以及基类。

**建立实验原型**

有些时候，除非你更好地了解了一些实现细节，否则很难判断一种设计方法是否奏效。比如说，在知道它能满足性能要求之前，你很难判断某种数据库的组织结构是否适用。

有一种技术能够低成本地解决这个问题，那就是建立试验性原型,即写出用于回答特定设计问题的、量最少且能够随时扔掉的代码。

