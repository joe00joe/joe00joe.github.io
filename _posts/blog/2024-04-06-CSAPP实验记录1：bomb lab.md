此实验有6个阶段，每个阶段的汇编代码对应的逻辑如下

### Q1

调用了一个`Strings_not_equal` 函数， 若返回不为零，引爆炸弹。根据函数名可知，它在比较输入字符串和内存中某个字符串是否相等。输入的字符串地址放在`rdi`中， 内存字符串的地址放在`rsi`中。根据`rsi`中的地址，打印出内存中的字符串，将此字符串输入即可。

### Q2

从输入读取6个数，如果与`phase_2`函数生成的6个数不完全相等，则boom!。函数使用循环生成这6个数，后一个数是前一个数的平方。

### Q3

此题考查符号表跳转。`phase_3`函数要求输入两个数，第一个数是符号表索引，另一个是匹配值 。根据索引读取符号表项指向的分支地址。并跳转到此分支。分支做的事很简单，将一个立即数读到`rax`中后，跳出分支。在函数结尾会测试匹配值，如果匹配值与`rax` 中立即数相等，则不引发boom。

### Q4

本题的难点在于确定输入的第一个参数值`x` 。`phase_4`函数将调用`func4(x)`,若返回值不为0，则boom。将`func4`翻译成c语言，大致如下：

```c
int func4(x, left, right){
    int mid = left + (right - left) / 2;
    if(x == mid){
        return 0;
    }else if( x < mid){
        return 2 * func4(x, left, mid - 1);
    }else{
        return 2 * func4(x, mid + 1, right) + 1;
    }
    
}
```

从以上代码可知，当`x = (left + right)/2`时返回0。

###  Q5

`phase_5`函数读取的6个索引值，根据索引值从内存中的`source`字符串数组读取6个字符，拼接成一个新的字符串。若新的字符串与内存中的`target`字符串相等，则不boom。

### Q6

内存中存在一个己排序的链表。链表结点中有两个字段，64位的整数`val`和下一结点r的地址next。 链表以64位整数`val`排序，现要求以`val`的低32位进行排序。

如何进行排序？

假设原始顺序为`1->2->3->4->5->6` ,重新排序后为`4->3->2->1->6->5`。`phase_6`函数将重排后的结点地址依次读取到栈中的连续的8字节内存单元中。比如说，第一个内存单元存储第4个链表节点的地址。随后phase_6遍历这些内存单元，将前一个内存单元指向结点的next设置为当前内存单元的值，即当前内存单元指向结点的首地址。如此便完成了重排。

如何将重排后的结点地址依次读取到栈中的连续的多个8字节内存单元中？

己知结点在原始链表中是第i个结点，从链表的第一个节点开始，移动指针i-1次，即可移动到第i个结点。将结点的首地址复制到栈中即可。





